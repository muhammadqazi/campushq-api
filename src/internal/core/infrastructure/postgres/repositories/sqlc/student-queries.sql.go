// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: student-queries.sql

package repositories

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertStudent = `-- name: InsertStudent :one
INSERT INTO students (
    student_id,
    first_name,
    surname,
    sex,
    role,
    status,
    access_status,
    acceptance_type,
    department_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
) RETURNING student_id
`

type InsertStudentParams struct {
	StudentID      int32       `json:"student_id"`
	FirstName      string      `json:"first_name"`
	Surname        string      `json:"surname"`
	Sex            string      `json:"sex"`
	Role           string      `json:"role"`
	Status         string      `json:"status"`
	AccessStatus   string      `json:"access_status"`
	AcceptanceType string      `json:"acceptance_type"`
	DepartmentID   pgtype.Int4 `json:"department_id"`
}

func (q *Queries) InsertStudent(ctx context.Context, arg InsertStudentParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertStudent,
		arg.StudentID,
		arg.FirstName,
		arg.Surname,
		arg.Sex,
		arg.Role,
		arg.Status,
		arg.AccessStatus,
		arg.AcceptanceType,
		arg.DepartmentID,
	)
	var student_id int32
	err := row.Scan(&student_id)
	return student_id, err
}

const selectLastInsertedStudentId = `-- name: SelectLastInsertedStudentId :one
SELECT student_id FROM students ORDER BY student_id DESC LIMIT 1
`

func (q *Queries) SelectLastInsertedStudentId(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, selectLastInsertedStudentId)
	var student_id int32
	err := row.Scan(&student_id)
	return student_id, err
}

const selectStudentById = `-- name: SelectStudentById :one
SELECT student_id, first_name, surname, sex, role, status, access_status, acceptance_type, graduation_date, supervisor_id, department_id, created_at, updated_at, deleted_at, is_active FROM students WHERE student_id = $1
`

func (q *Queries) SelectStudentById(ctx context.Context, studentID int32) (Student, error) {
	row := q.db.QueryRow(ctx, selectStudentById, studentID)
	var i Student
	err := row.Scan(
		&i.StudentID,
		&i.FirstName,
		&i.Surname,
		&i.Sex,
		&i.Role,
		&i.Status,
		&i.AccessStatus,
		&i.AcceptanceType,
		&i.GraduationDate,
		&i.SupervisorID,
		&i.DepartmentID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.IsActive,
	)
	return i, err
}

const updateStudent = `-- name: UpdateStudent :exec
UPDATE 
    students
SET
    first_name = COALESCE($2, first_name),
    surname = COALESCE($3, surname),
    role = COALESCE($4, role),
    status = COALESCE($5, status),
    access_status = COALESCE($6, access_status),
    department_id = COALESCE($7, department_id),
    supervisor_id = COALESCE($8, supervisor_id),
    updated_at = CURRENT_TIMESTAMP
WHERE
    student_id = $1
`

type UpdateStudentParams struct {
	StudentID    int32       `json:"student_id"`
	FirstName    pgtype.Text `json:"first_name"`
	Surname      pgtype.Text `json:"surname"`
	Role         pgtype.Text `json:"role"`
	Status       pgtype.Text `json:"status"`
	AccessStatus pgtype.Text `json:"access_status"`
	DepartmentID pgtype.Int4 `json:"department_id"`
	SupervisorID pgtype.Int4 `json:"supervisor_id"`
}

func (q *Queries) UpdateStudent(ctx context.Context, arg UpdateStudentParams) error {
	_, err := q.db.Exec(ctx, updateStudent,
		arg.StudentID,
		arg.FirstName,
		arg.Surname,
		arg.Role,
		arg.Status,
		arg.AccessStatus,
		arg.DepartmentID,
		arg.SupervisorID,
	)
	return err
}
